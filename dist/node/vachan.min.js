const vachan={};vachan.Pending=Symbol("Pending"),vachan.Fulfilled=Symbol("Fulfilled"),vachan.Rejected=Symbol("Rejected"),vachan.Macro=Symbol("Macro"),vachan.Micro=Symbol("Micro"),vachan.Sync=Symbol("Sync"),vachan.default_type=vachan.Macro,vachan.realm=require("conciseee")();class P{static resolve(e){return new P(t=>t(e))}static reject(e){return new P((t,a)=>a(e))}static all(...e){return 1==e.length&&Array.isArray(e[0])&&(e=e[0]),new P((t,a)=>{let n=0,i=[],s=a=>{n++,i.push(a),(a=>n==e.length?t(i):0)()},h=e=>a(e);for(let t of e)t.then(s,h)})}static race(...e){return 1==e.length&&Array.isArray(e[0])&&(e=e[0]),new P(t=>{let a=!1,n=e=>{a||(a=!0,t(e))},i=e=>reject(e);for(let t of e)t.then(n,i)})}static delay(e,t){return new P(a=>setTimeout(()=>a(e),t))}constructor(e,t=!0,a=vachan.default_type){this.async=t,this.type=a,this.state=vachan.Pending,this.value=void 0,this.success_handler=[],this.failure_handler=[],e&&(this.logic=e,this.logic(e=>this.resolve(e),e=>this.reject(e),this)),vachan.realm.emit("Created",this)}isFullfilled(){return this.state===vachan.Fulfilled}isRejected(){return this.state===vachan.Rejected}isPending(){return this.state===vachan.Pending}resolve(e){if(this.state===vachan.Pending){this.state=vachan.Fulfilled,this.value=e;for(let t of this.success_handler)this.queueTask(()=>t(e));vachan.realm.emit("Fulfilled",this)}}reject(e){if(this.state===vachan.Pending){this.state=vachan.Rejected,this.value=e;for(let t of this.failure_handler)this.queueTask(()=>t(e));vachan.realm.emit("Rejected",this)}}queueTask(e){this.async?this.type===vachan.Micro?(process.nextTick(e),vachan.realm.emit("TaskQueued",vachan.Micro,e)):this.type===vachan.Macro&&(setTimeout(e,0),vachan.realm.emit("TaskQueued",vachan.Macro,e)):(e(),vachan.realm.emit("TaskQueued",vachan.Sync,e))}then(e,t){return"function"!=typeof e&&(e=void 0),"function"!=typeof t&&(t=void 0),new P((a,n,i)=>{let s=e=>{if(null==e)a(e);else if(e===i)n(new TypeError("It cannot return the same Promise"));else if(e instanceof P){let t=!1,a=!1;e.then(e=>{t||a||s(e),t=!0},e=>{t||a||n(e),a=!0}),vachan.realm.emit("Rechained",e,i)}else if(e instanceof Object||e instanceof Function||"object"==typeof e||"function"==typeof e){let t=!1,h=!1;try{let c=e.then;void 0!==c&&c instanceof Function&&"function"==typeof c?(c.call(e,e=>{t||h||s(e),t=!0},e=>{t||h||n(e),h=!0}),vachan.realm.emit("Rechained",e,i)):a(e)}catch(e){t||h||n(e)}}else a(e)},h=e=>t=>{let a;try{a=e(t),s(a)}catch(e){n(e)}};this.state===vachan.Fulfilled?(e?this.queueTask(()=>h(e)(this.value)):this.queueTask(()=>a(this.value)),vachan.realm.emit("Preresolved",this,i,e)):this.state===vachan.Rejected?(t?this.queueTask(()=>h(t)(this.value)):this.queueTask(()=>n(this.value)),vachan.realm.emit("Prerejected",this,i,t)):(e?this.success_handler.push(h(e)):this.success_handler.push(a),t?this.failure_handler.push(h(t)):this.failure_handler.push(n),vachan.realm.emit("Chained",this,i))})}catch(e){return this.then(void 0,e)}finally(e){return this.then(e,e)}delay(e){return new P((t,a)=>{this.then(a=>setTimeout(()=>t(a),e),t=>setTimeout(()=>a(t),e))})}}vachan.P=P,module.exports.P=vachan.P,module.exports.Macro=vachan.Macro,module.exports.Micro=vachan.Micro;